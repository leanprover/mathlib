/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
import algebra.algebra.non_unital
import linear_algebra.finsupp

/-!
# Magma algebras

If apply the construction of the group algebra but to a magma rather than a group, we obtain an
algebra which is neither unital nor associative in general, the so-called magma algebra. It is
adjoint to the forgetful functor that turns an algebra into a magma.

Although we cannot say much about such algebras since they sit in a very general class, they are
useful for this same reason. In particular they can be used to construct free functors for
categories of non-associative algebras, e.g., free Lie algebras.

## Main definitions

  * `magma_algebra`
  * `magma_algebra.non_unital_non_assoc_algebra`
  * `magma_algebra.lift`

## Tags

magma algebra, non-associative algebra
-/

universes u v w w₁

noncomputable theory

section magma_algebra

variables (R : Type u) (M : Type v) [semiring R]

/-- The magma algebra over a semiring `R` generated by the magma `M`. It is the type of finite
formal `R`-linear combinations of terms of `M`, endowed with the convolution product. -/
@[derive [inhabited, add_comm_monoid, has_coe_to_fun]]
def magma_algebra := M →₀ R

namespace magma_algebra

variables {R M}

instance : semimodule R (magma_algebra R M) := finsupp.semimodule M R

/-- A synonym for `finsupp.single` which forces it to take values in `magma_algebra R M`. -/
private abbreviation single (m : M) (t : R) : magma_algebra R M := finsupp.single m t

variables [has_mul M]

open finsupp (hiding single)

/-- A multiplication on `M` determines a convolution product on `magma_algebra R M`. Note that this
should not be placed directly on `M →₀ R` since it carries the pointwise multiplication `has_mul`
instance. -/
instance : has_mul (magma_algebra R M) :=
⟨λ a b, a.sum $ λ m₁ t₁, b.sum $ λ m₂ t₂, finsupp.single (m₁ * m₂) (t₁ * t₂)⟩

lemma mul_def {a b : magma_algebra R M} :
  a * b = a.sum (λ m₁ t₁, b.sum $ λ m₂ t₂, finsupp.single (m₁ * m₂) (t₁ * t₂)) :=
rfl

instance : distrib (magma_algebra R M) :=
{ mul           := (*),
  add           := (+),
  left_distrib  := λ a b c, by simp only [mul_def, sum_add_index, mul_add, mul_zero, single_zero,
    single_add, eq_self_iff_true, forall_true_iff, forall_3_true_iff, sum_add],
  right_distrib := λ a b c, by simp only [mul_def, sum_add_index, add_mul, zero_mul, single_zero,
    single_add, eq_self_iff_true, forall_true_iff, forall_3_true_iff, sum_add, sum_zero],
  .. finsupp.add_comm_monoid }

instance : mul_zero_class (magma_algebra R M) :=
{ zero      := 0,
  mul       := (*),
  zero_mul  := assume f, by simp only [mul_def, sum_zero_index],
  mul_zero  := assume f, by simp only [mul_def, sum_zero_index, sum_zero], }

instance : non_unital_non_assoc_semiring (magma_algebra R M) :=
{ ..(infer_instance : add_comm_monoid _),
  ..(infer_instance : distrib _),
  ..(infer_instance : mul_zero_class _), }

lemma smul_mul_assoc (t : R) (a b : magma_algebra R M) : (t • a) * b = t • (a * b) :=
begin
  ext,
  simp only [mul_def, mul_sum, smul_apply, sum_smul_index, implies_true_iff, eq_self_iff_true,
    single_zero, sum_apply, smul_eq_mul, single_apply, mul_ite, mul_zero, sum_zero, zero_mul,
    mul_assoc],
end

/-- If the coefficients are commutative amongst themselves, they also commute with the
multiplication. -/
lemma mul_smul_comm {R : Type u} [comm_semiring R] (t : R) (a b : magma_algebra R M) :
  a * (t • b) = t • (a * b) :=
begin
  ext,
  simp only [mul_def, mul_sum, smul_apply, sum_smul_index, implies_true_iff, eq_self_iff_true,
    single_zero, sum_apply, smul_eq_mul, single_apply, mul_ite, mul_zero, mul_left_comm],
end

lemma mul_sum_single
  {A : Type w} [non_unital_non_assoc_semiring A] [non_unital_non_assoc_algebra R A]
  (m : M) (t : R) {b : magma_algebra R M} {f : mul_hom M A} :
  ((single m t) * b).sum (λ m t, t • f m) =
  ((single m t).sum (λ m t, t • f m)) * (b.sum (λ m t, t • f m)) :=
begin
  simp only [mul_def, zero_mul, sum_single_index, sum_zero, single_zero, zero_smul],
  apply induction_linear b,
  { simp only [sum_zero_index, mul_zero], },
  { intros b₁ b₂ hb₁ hb₂,
    simp only [sum_add_index, hb₁, hb₂, left_distrib, add_smul, single_add, implies_true_iff,
      eq_self_iff_true, zero_smul, forall_3_true_iff, single_eq_zero, mul_zero], },
  { intros m' t',
    simp only [mul_def, sum_single_index, single_eq_zero, zero_smul, zero_mul, mul_zero],
    rw [mul_hom.map_mul, non_unital_non_assoc_algebra.smul_mul_assoc,
      non_unital_non_assoc_algebra.mul_smul_comm, mul_smul], },
end

lemma mul_sum {A : Type w} [non_unital_non_assoc_semiring A] [non_unital_non_assoc_algebra R A]
  {a b : magma_algebra R M} {f : mul_hom M A} :
  (a * b).sum (λ m t, t • f m) = (a.sum (λ m t, t • f m)) * (b.sum (λ m t, t • f m)) :=
begin
  apply induction_linear a,
  { simp only [zero_mul, sum_zero_index], },
  { intros a₁ a₂ ha₁ ha₂,
    simp only [mul_def, sum_add_index, add_smul, implies_true_iff, eq_self_iff_true, zero_smul,
      forall_3_true_iff],
    rw sum_add_index,
    { rw sum_add_index,
      { simp only [mul_def] at ha₁ ha₂, simp only [ha₁, ha₂, right_distrib], },
      { simp only [implies_true_iff, eq_self_iff_true, zero_smul], },
      { simp only [add_smul, eq_self_iff_true, forall_3_true_iff], }, },
    { simp only [zero_mul, implies_true_iff, eq_self_iff_true, sum_zero, single_zero], },
    { intros m t t', simp only [add_mul, single_add, sum_add], }, },
  { intros m t, apply mul_sum_single, },
end

instance {R : Type u} [comm_semiring R] : non_unital_non_assoc_algebra R (magma_algebra R M) :=
{ smul_mul_assoc' := smul_mul_assoc,
  mul_smul_comm'  := mul_smul_comm,
  ..(infer_instance : semimodule R _) }

variables (R)

/-- The embedding of a magma into its magma algebra. -/
def of : mul_hom M (magma_algebra R M) :=
{ to_fun   := λ m, single m 1,
  map_mul' := λ m₁ m₂, by simp only [mul_def, mul_one, sum_single_index, single_eq_zero, mul_zero] }

@[simp] lemma of_apply (m : M) : of R m = single m 1 := rfl

/-- An auxiliary definition for used in the construction of `lift` below. -/
def lift_aux (R : Type u) [comm_semiring R]
  {A : Type w} [non_unital_non_assoc_semiring A] [non_unital_non_assoc_algebra R A]
  (f : mul_hom M A) : M → R →ₗ[R] A :=
λ m, { to_fun    := λ t, t • f m,
       map_add'  := λ t₁ t₂, add_smul t₁ t₂ (f m),
       map_smul' := λ t₁ t₂, by { rw smul_smul, refl, }, }

/-- The universal property of the magma algebra expressing its adjointness. -/
def lift (R : Type u) [comm_semiring R]
  {A : Type w} [non_unital_non_assoc_semiring A] [non_unital_non_assoc_algebra R A] :
  mul_hom M A ≃ non_unital_non_assoc_algebra_hom R (magma_algebra R M) A :=
{ to_fun    := λ f,
    { to_fun    := λ a, a.sum (λ m, lift_aux R f m),
      map_add'  := λ a₁ a₂, sum_add_index' (λ m, (lift_aux R f m).to_add_monoid_hom),
      map_smul' := λ t a, sum_smul_index_linear_map',
      map_mul'  := λ a₁ a₂, mul_sum, },
  inv_fun   := λ F, (F : mul_hom (magma_algebra R M) A).comp (of R),
  left_inv  := λ f, by { ext, simp [lift_aux], },
  right_inv := λ F, by
    { ext, simp only [lift_aux, non_unital_non_assoc_algebra_hom.coe_mk, linear_map.coe_mk,
        non_unital_non_assoc_algebra_hom.coe_to_mul_hom, function.comp_app, mul_hom.coe_comp,
        of_apply, ← F.map_smul, smul_single, mul_one, algebra.id.smul_eq_mul],
      erw ← add_monoid_hom.map_finsupp_sum (F : magma_algebra R M →ₗ[R] A).to_add_monoid_hom,
      rw sum_single, refl, }, }

lemma lift_apply (R : Type u) [comm_semiring R]
  {A : Type w} [non_unital_non_assoc_semiring A] [non_unital_non_assoc_algebra R A]
  (f : mul_hom M A) (a : magma_algebra R M) : lift R f a = a.sum (λ m t, t • f m) :=
rfl

@[simp] lemma lift_comp_of (R : Type u) [comm_semiring R]
  {A : Type w} [non_unital_non_assoc_semiring A] [non_unital_non_assoc_algebra R A]
  (g : non_unital_non_assoc_algebra_hom R (magma_algebra R M) A) :
  lift R ((g : mul_hom (magma_algebra R M) A).comp (of R)) = g :=
(lift R).apply_symm_apply g

end magma_algebra

end magma_algebra
