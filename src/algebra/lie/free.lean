/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
import algebra.lie.of_associative
import algebra.free_non_unital_non_associative_algebra

/-!
# Free Lie algebras

Given a commutative ring `R` and a type `X` we construct the free Lie algebra on `X` with
coefficients in `R` together with its universal property.

## Main definitions

  * `free_lie_algebra`
  * `free_lie_algebra.lift`
  * `free_lie_algebra.of`

## Implementation details

### Quotient of free non-unital, non-associative algebra

We follow [N. Bourbaki, *Lie Groups and Lie Algebras, Chapters 1--3*](bourbaki1975) and construct
the free Lie algebra as a quotient of the free non-unital, non-associative algebra. Since we do not
currently have definitions of (two-sided) ideals, lattices of ideals, and quotients for
`non_unital_non_assoc_algebra`, we construct our quotient using the low-level `quot` function on
an inductively-defined relation. In fact even Bourbaki gloss over the issue of non-associative
quotients; see also [Bonfiglioli and Fulci](bonfiglioli_fulci-2012).

### Alternative construction (often used over field of charteristic zero, but not by us)

Note that by universality of the Free Lie algebra, there is a natural map:
`ρ : free_lie_algebra R X →ₗ⁅R⁆ free_algebra R X`, where `free_algebra R X` is the free unital,
associative algebra, regarded as a Lie algebra via the ring commutator.

By uniqueness, the image of `ρ` is the Lie subalgebra generated by `X` in the the free algebra:
`lie_subalgebra.lie_span R (free_algebra R X) (set.range (free_algebra.ι R))`.
Some authors thus take this as a definition of the Free Lie algebra but this is valid when `ρ`
is injective which I believe is not true for general `R`. The only proof I know that `ρ` is
injective relies on using the injectivity of the map from a Lie algebra to its universal enveloping
algebra, which is certainly not true in general. Furthermore, even when a Lie algbebra does inject
into its universal enveloping algebra, the only proofs I know of this fact use the
Poincaré–Birkhoff–Witt theorem.

## Tags

lie algebra, free algebra, non-unital, non-associative, universal property, forgetful functor,
adjoint functor
-/

universes u v w w₁ w₂

noncomputable theory

variables (R : Type u) (X : Type v) [comm_ring R]

section move_to_appropriate_file

variables (L : Type v) [lie_ring L] [lie_algebra R L]

def lie_ring.to_non_unital_non_assoc_semiring : non_unital_non_assoc_semiring L :=
{ mul           := has_bracket.bracket,
  left_distrib  := lie_add,
  right_distrib := add_lie,
  zero_mul      := zero_lie,
  mul_zero      := lie_zero,
  ..(infer_instance : add_comm_monoid L) }

local attribute [instance] lie_ring.to_non_unital_non_assoc_semiring

def lie_algebra.to_non_unital_non_assoc_algebra : non_unital_non_assoc_algebra R L :=
{ smul_mul_assoc' := smul_lie,
  mul_smul_comm'  := lie_smul, }

end move_to_appropriate_file

namespace free_lie_algebra

inductive rel : (lib R X) → (lib R X) → Prop
| refl {a : lib R X} : rel a a
| lie_self (a : lib R X) : rel (a * a) 0
| leibniz_lie (a b c : lib R X) : rel (a * (b * c)) (((a * b) * c) + (b * (a * c)))
| smul (t : R) (a b : lib R X) : rel a b → rel (t • a) (t • b)
| add (a b c : lib R X) : rel a b → rel (a + c) (b + c)
| mul_left (a b c : lib R X) : rel b c → rel (a * b) (a * c)
| mul_right (a b c : lib R X) : rel a b → rel (a * c) (b * c)

end free_lie_algebra

/-- The free Lie algebra on the type `X` with coefficients in the ring `R`. -/
def free_lie_algebra := quot (free_lie_algebra.rel R X)

namespace free_lie_algebra

instance : has_scalar R (free_lie_algebra R X) :=
{ smul := λ t a, quot.lift_on a (λ x, quot.mk _ (t • x)) (λ a b h, quot.sound (rel.smul t a b h)), }

instance : has_add (free_lie_algebra R X) :=
{ add            := quot.map₂ (+)
  (λ a b c, by { rw [add_comm _ b, add_comm _ c], exact rel.add b c a }) (λ a b c, rel.add a b c), }

instance : add_comm_group (free_lie_algebra R X) :=
{ add_comm       := by { rintros ⟨a⟩ ⟨b⟩, apply quot.sound, rw add_comm, exact rel.refl, },
  add_assoc      := by { rintros ⟨a⟩ ⟨b⟩ ⟨c⟩, apply quot.sound, rw add_assoc, exact rel.refl, },
  zero           := quot.mk _ 0,
  zero_add       := by { rintros ⟨a⟩, apply quot.sound, rw zero_add, exact rel.refl, },
  add_zero       := by { rintros ⟨a⟩, apply quot.sound, rw add_zero, exact rel.refl, },
  neg            := λ x, (-1 : R) • x,
  sub            := λ x y, x + ((-1 : R) • y),
  sub_eq_add_neg := λ x y, rfl,
  add_left_neg   :=
    by { rintros ⟨a⟩, apply quot.sound, erw [neg_smul, one_smul, add_left_neg], exact rel.refl, },
  ..(infer_instance : has_add _)}

instance : has_bracket (free_lie_algebra R X) (free_lie_algebra R X) :=
{ bracket := quot.map₂ (*) (λ a b c, rel.mul_left a b c) (λ a b c, rel.mul_right a b c), }

instance : lie_ring (free_lie_algebra R X) :=
{ add_lie     := by { rintros ⟨a⟩ ⟨b⟩ ⟨c⟩, apply quot.sound, rw add_mul, exact rel.refl, },
  lie_add     := by { rintros ⟨a⟩ ⟨b⟩ ⟨c⟩, apply quot.sound, rw mul_add, exact rel.refl, },
  lie_self    := by { rintros ⟨a⟩, exact quot.sound (rel.lie_self a), },
  leibniz_lie := by { rintros ⟨a⟩ ⟨b⟩ ⟨c⟩, exact quot.sound (rel.leibniz_lie a b c), }, }

instance : semimodule R (free_lie_algebra R X) :=
{ one_smul  := by { rintros ⟨a⟩, apply quot.sound, rw one_smul, exact rel.refl, },
  mul_smul  := by { rintros t₁ t₂ ⟨a⟩, apply quot.sound, rw mul_smul, exact rel.refl, },
  add_smul  := by { rintros t₁ t₂ ⟨a⟩, apply quot.sound, rw add_smul, exact rel.refl, },
  smul_add  := by { rintros t ⟨a⟩ ⟨b⟩, apply quot.sound, rw smul_add, exact rel.refl, },
  zero_smul := by { rintros ⟨a⟩, apply quot.sound, rw zero_smul, exact rel.refl, },
  smul_zero := λ t, by { apply quot.sound, rw smul_zero, exact rel.refl, }, }

instance : lie_algebra R (free_lie_algebra R X) :=
{ lie_smul := by { rintros t ⟨a⟩ ⟨c⟩, apply quot.sound,
    rw non_unital_non_assoc_algebra.mul_smul_comm, exact rel.refl, } }

variables {X}

def of : X → free_lie_algebra R X := λ x, quot.mk _ (lib.of R x)

variables {L : Type w} [lie_ring L] [lie_algebra R L]

local attribute [instance] lie_ring.to_non_unital_non_assoc_semiring
local attribute [instance] lie_algebra.to_non_unital_non_assoc_algebra

def lift_aux (f : X → L) := lib.lift R f

lemma lift_aux_map_smul (f : X → L) (t : R) (a : lib R X) :
  lift_aux R f (t • a) = t • lift_aux R f a :=
non_unital_non_assoc_algebra_hom.map_smul _ t a

lemma lift_aux_map_add (f : X → L) (a b : lib R X) :
  lift_aux R f (a + b) = (lift_aux R f a) + (lift_aux R f b) :=
non_unital_non_assoc_algebra_hom.map_add _ a b

lemma lift_aux_map_mul (f : X → L) (a b : lib R X) :
  lift_aux R f (a * b) = ⁅lift_aux R f a, lift_aux R f b⁆ :=
non_unital_non_assoc_algebra_hom.map_mul _ a b

lemma lift_aux_spec (f : X → L) (a b : lib R X) (h : free_lie_algebra.rel R X a b) :
  lift_aux R f a = lift_aux R f b :=
begin
  induction h with c c a' b' c' t a' b' h₁ h₂ a' b' c' h₁ h₂ a' b' c' h₁ h₂ a' b' c' h₁ h₂,
  { -- rel.refl
    refl, },
  { -- rel.lie_self
    rw [lift_aux_map_mul, non_unital_non_assoc_algebra_hom.map_zero, lie_self], },
  { -- rel.leibniz_lie
    simp only [lift_aux_map_mul, lift_aux_map_add], rw leibniz_lie, },
  { -- rel.smul
    simp only [lift_aux_map_smul, h₂], },
  { -- rel.add
    simp only [lift_aux_map_add, h₂], },
  { -- rel.mul_left
    simp only [lift_aux_map_mul, h₂], },
  { -- rel.mul_right
    simp only [lift_aux_map_mul, h₂], },
end

def lift : (X → L) ≃ (free_lie_algebra R X →ₗ⁅R⁆ L) :=
{ to_fun    := λ f,
    { to_fun    := λ c, quot.lift_on c (lift_aux R f) (lift_aux_spec R f),
      map_add'  := by { rintros ⟨a⟩ ⟨b⟩, rw ← lift_aux_map_add, refl, },
      map_smul' := by { rintros t ⟨a⟩, rw ← lift_aux_map_smul, refl, },
      map_lie'  := by { rintros ⟨a⟩ ⟨b⟩, rw ← lift_aux_map_mul, refl, }, },
  inv_fun   := λ F, F ∘ (of R),
  left_inv  :=
    λ f, by { ext x, simp only [lift_aux, of, quot.lift_on_mk, lie_hom.coe_mk, function.comp_app,
      lib.lift_of_apply], },
  right_inv :=
    λ F, by { ext ⟨a⟩, simp only [lift_aux, of, quot.lift_on_mk, lie_hom.coe_mk],
    let F' : non_unital_non_assoc_algebra_hom R (lib R X) L :=
    { to_fun    := F ∘ (quot.mk (rel R X)),
      map_add'  := λ x y, by { simp only [function.comp_app, ← F.map_add], congr, },
      map_smul' := λ t x, by { simp only [function.comp_app, ← F.map_smul], congr, },
      map_mul'  :=
        λ x y, by { simp only [function.comp_app], change _ = ⁅_, _⁆, rw ← F.map_lie, congr, }, },
    change lib.lift R (F' ∘ (lib.of R)) a = F' a, congr,
    exact lib.lift_comp_of R F', }, }

@[simp] lemma lift_symm_apply (F : free_lie_algebra R X →ₗ⁅R⁆ L) : (lift R).symm F = F ∘ (of R) :=
rfl

variables {R}

@[simp] lemma of_comp_lift (f : X → L) : (lift R f) ∘ (of R) = f :=
(lift R).left_inv f

@[simp] lemma lift_of_apply (f : X → L) (x) : lift R f (of R x) = f x :=
by rw [← function.comp_app (lift R f) (of R) x, of_comp_lift]

@[simp] lemma lift_unique (f : X → L) (g : free_lie_algebra R X →ₗ⁅R⁆ L) :
  g ∘ (of R) = f ↔ g = lift R f :=
(lift R).symm_apply_eq

attribute [irreducible] of lift

@[simp] lemma lift_comp_of (F : free_lie_algebra R X →ₗ⁅R⁆ L) : lift R (F ∘ (of R)) = F :=
by { rw ← lift_symm_apply, exact (lift R).apply_symm_apply F, }

/-- See note [partially-applied ext lemmas]. -/
@[ext] lemma hom_ext {F₁ F₂ : free_lie_algebra R X →ₗ⁅R⁆ L} (h : F₁ ∘ (of R) = F₂ ∘ (of R)) :
  F₁ = F₂ :=
by { rw [← lift_symm_apply, ← lift_symm_apply] at h, exact (lift R).symm.injective h, }

end free_lie_algebra
